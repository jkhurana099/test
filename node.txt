set NODE_ENV=development&& nodemon server.js

https://www.twilio.com/blog/2017/08/working-with-environment-variables-in-node-js.html
https://www.dynatrace.com/blog/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/
Edit: Alright – but how do I set NODE_ENV properly?
I was asked that question on facebook after releasing this post and I agree that it really makes sense to cover that.

NODE_ENV works like any other environment variable (e.g. PATH) and it depends on your platform how to set it:

Linux and OSX: export NODE_ENV=production
Windows: SET NODE_ENV=production
On all platforms you can explicitly set it when starting your application like that: NODE_ENV=production node myapp.js. You may also use a module like dotenv to set it from an .env file in your application directory. That said, you should avoid setting the environment directly in your code because this contradicts the purpose of environment variables.

-----------------
https://stackoverflow.com/questions/34855352/how-in-general-does-node-js-handle-10-000-concurrent-requests
https://stackoverflow.com/questions/39584439/does-node-js-support-parallelism
----------------
NODEJS BEST PRACTICES

Start every new project with npm init
By default, npm doesn’t save installed dependencies to package.json (and you should always track your dependencies!).

If you use the --save flag to auto-update package.json, 
So later if u will do npm install it will automatically add dependencies to package.json
https://www.codementor.io/mattgoldspink/nodejs-best-practices-du1086jja(2nd point pending only)

Use a logging library to increase errors visibility->
console.log is great but it has limits in a production application. , they allow you to set levels for each log message — whether it’s a debug, info, warning, or error.
a logging library allows me to quickly search all my log messages 
winston - https://github.com/winstonjs/winston.

Ensure your app automatically restarts->
using pm2(pending)

Add scripts to your package.json->
If there’s one thing all applications need, it’s a launch script. Good thing NPM has a standard way to start all node applications.
Simply add a scripts property and object to your package.json with a start key. It’s value should be the command to launch your app. For example:

"scripts": {
  "start": "node myapp.js"
}
As soon as someone runs npm start, NPM will run node myapp.js with all the dependencies from node_modules/.bin

"scripts": {
  "postinstall": "bower install && grunt build",
  "start": "node myapp.js",
  "test": "node ./node_modules/jasmine/bin/jasmine.js"
}
The postinstall script is run after npm install is run. There’s also preinstall if you need to run something before all the NPM dependencies are installed.
The test script is run when someone runs npm test. This is a nice simple way for someone to be able to run your tests without figuring out if you’ve chosen to use Jasmine, 
Mocha, Selenium, etc.

Cluster your app
Since the node runtime is limited to a single CPU core and about 1.5 GB of memory, deploying a non-clustered node app on a large server is a huge waste of resources.
To take advantage of multiple cores and memory beyond 1.5 GB, bake Cluster support into your app. Even if you’re only running a single process on small hardware today,
 Cluster gives you easy flexibility for the future.

-----------------------------
http://nodewebapps.com/2017/01/03/13-security-best-practices-for-your-web-application/

What is HttpOnly?
According to the Microsoft Developer Network, HttpOnly is an additional flag included in a Set-Cookie HTTP response header. Using the HttpOnly flag when generating a cookie 
helps mitigate the risk of client side script accessing the protected cookie (if the browser supports it).
If the HttpOnly flag (optional) is included in the HTTP response header, the cookie cannot be accessed through client side script (again if the browser supports this flag).
 As a result, even if a cross-site scripting (XSS) flaw exists, and a user accidentally accesses a link that exploits this flaw, the browser (primarily Internet Explorer) will 
not reveal the cookie to a third party.
If a browser does not support HttpOnly and a website attempts to set an HttpOnly cookie, the HttpOnly flag will be ignored by the browser, thus creating a traditional, script
 accessible cookie. As a result, the cookie (typically your session cookie) becomes vulnerable to theft of modification by malicious script. Mitigating.

The Cross-site Scripting (XSS) Vulnerability

Cross-site Scripting, also known as XSS, is a way of bypassing the SOP concept. Whenever HTML code is generated dynamically, and the user input is not sanitized and is reflected on the page an attacker could insert his own HTML code. The web browser will still show the user's code since it pertains to the website where it is injected.
In such case an attacker can easily insert javascript code which would run under the site's context. By doing so the attacker is able to access other pages on the same domain and can read data like CSRF-Tokens or the set cookies.

If the cookies, which typically contain session identifier information can be read by the javascript, the attacker can use them on his own browser and login to the web 
application as the victim. If that does not work the attacker can still read private information from the pages, such as read CSRF tokens and make requests on behalf of the
 user.

https://dzone.com/articles/what-are-microservices-actually
http://www.microtica.com/2016/10/discovering-microservices/
https://dzone.com/articles/monolithic-vs-microservice-architecture

-----
ALL ABOUT NODEJS MICROSERVICES
https://github.com/miguellgt/books/blob/master/microservices/developing-microservices-node-js.pdf

-----
