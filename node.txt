why callback or promises

suppose you have 2 async functions and 1 function have dependency on other so if the operations are asyunchronous then while processing first control will go to
 second func and it starts processing so at that time qwe dont get expected result because of some dependency so in that case we should use promise or callback so 
that after completion of one function second will start processing

Promises provide a more clear way of representing sequential asynchronous operations in javascript. They are effectively a different syntax for achieving the same effect
 as callbacks bcz  main problem with callbacks is: nested callbacks. In nested callbacks, it is very tough to test/maintain the codes.
The advantage of promises is increased readability.the primary advantage of using Promise is consistency
Promises and Callbacks are not fundamentally different. Promises is advisable in nested callbacks
aAsync()
  .then(bAsync)
  .then(cAsync)
  .done(finish);
is much more readable then the equivalent of passing each of those individual functions as callbacks, like

Async(function(){
    return bAsync(function(){
        return cAsync(function(){
         ....//code here
        })
    })
});

https://www.quora.com/What-are-the-most-popular-Node-js-interview-questions

-->What is Event Driven Programming followed in Node.js?.
It may be surprising to learn that the Node.js is an application that runs on a single thread but we can still achieve concurrency in Node.js with the help of event 
and callback functions. Callback can be defined as an event which is invoked or called immediately after the completion of a particular task. Almost every API of Node.js
 is asynchronous and single-threaded. Therefore, they use asynchronous function calls in order to maintain concurrency. Node uses the observer pattern that helps the node 
thread to keep an event loop.
An event is different as compared to the callback function. The former works on an observer pattern however, the latter works like an event but it is called only when an
 asynchronous function returns its result. The functions which listen to the events act as Observers. Therefore, when an event gets fired, the execution of the listener
 function starts immediately.

In Node.js, the events are heavily used which make Node.js a pretty fast application as compared to the other similar technologies. As soon as the server is started by the
Node, it initiates its variables, declares functions and then waits for the event to occur. There are multiple in-built event modules which are available in Node.js and
through these event modules and the EventEmitter class that bind events, we can generate customized event-listeners.
Node.js’s ‘events’ module is used to create an event, event handler, and event emitter. 

get example frm tutorialspoint

-->How can we handle blocking I/O operations in Node.js?
-->What is the difference between Asynchronous and Non-blocking?

-->HOW TO INCLUDE EXTERNAL LIBRARIES BY REQUIRING MODULES IN NODE.JS?
In node.js, we use require keyword to include external libraries. For example,

var http = require(‘http’);

We can also include relative files as shown below:

var myFile = require(‘./myFile’); // loads myFile.js

To install modules from npm(node package manager),

$ npm install express

Modules aren’t automatically injected into the global scope, but instead you just assigned them to a variable of your choice.
so we have to create one instance of the particular module

-->What happens if we call require() method to load same module multiple times in Node.js?
Modules are cached after the first time they are loaded. This means (among other things) that every call to require('foo') will get exactly the same object returned, 
Multiple calls to require('foo') may not cause the module code to be executed multiple times. 
using require does not duplicate anything. It loads the module and it caches it, so calling require again will get it from memory.
Also package.json does not load anything and does not interact with your app at all. It is only used for npm.

-->What is Tracing in Node.js?
Trace Event provides a mechanism to centralize tracing information generated by V8, Node core, and userspace code.
Tracing can be enabled by passing the --trace-events-enabled flag when starting a Node.js application.
Running Node.js with tracing enabled will produce log files that can be opened in the chrome://tracing tab of Chrome.



-->GLOBAL OBJECTS
Node.js global objects are global in nature and they are available in all modules. We do not need to include these objects in our application, rather we can use them directly.
EXAMPLES->__dirname,__filename,setTimeout(cb, ms),clearTimeout(t),setInterval(cb, ms),Console,Process
-->__dirname

The directory name of the current module. This the same as the path.dirname() of the __filename.

Example: running node example.js from /Users/mjr
console.log(__dirname);
// Prints: /Users/mjr
console.log(path.dirname(__filename));
// Prints: /Users/mjr


-->__filename
The file name of the current module. This is the resolved absolute path of the current module file.

For a main program this is not necessarily the same as the file name used in the command line.
See __dirname for the directory name of the current module.

Examples:
Running node example.js from /Users/mjr

console.log(__filename);
// Prints: /Users/mjr/example.js
console.log(__dirname);
// Prints: /Users/mjr


-->Given two modules: a and b, where b is a dependency of a and there is a directory structure of:
/Users/mjr/app/a.js
/Users/mjr/app/node_modules/b/b.js
References to __filename within b.js will return /Users/mjr/app/node_modules/b/b.js while references to __filename within a.js will return /Users/mjr/app/a.js.

-->console
Node.js console is a global object and is used to print different levels of messages to stdout and stderr. There are built-in methods to be used for printing informational,
 warning, and error messages.
console.info
console.log
console.warn

-->setTimeout(cb, ms)
The setTimeout(cb, ms) global function is used to run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity
 and system load. A timer cannot span more than 24.8 days.
This function returns a value that represents the timer which can be used to clear the timer.

function printHello(){
   console.log( "Hello, World!");
}
// Now call above function after 2 seconds
setTimeout(printHello, 2000);

-->clearTimeout(t)
The clearTimeout(t) global function is used to stop a timer that was previously created with setTimeout(). Here t is the timer returned by the setTimeout() function.

function printHello(){
   console.log( "Hello, World!");
}
// Now call above function after 2 seconds
var t = setTimeout(printHello, 2000);
// Now clear the timer
clearTimeout(t);

-->setInterval(cb, ms)
The setInterval(cb, ms) global function is used to run callback cb repeatedly after at least ms milliseconds. The actual delay depends on external factors like OS
 timer granularity and system load. A timer cannot span more than 24.8 days.
This function returns an opaque value that represents the timer which can be used to clear the timer using the function clearInterval(t).

function printHello(){
   console.log( "Hello, World!");
}
// Now call above function after 2 seconds
setInterval(printHello, 2000);

The above program will execute printHello() after every 2 second.

-->Process
he process object is a global object and can be accessed from anywhere that provides information about the current Node.js process.
 There are several methods available in a process object.
Process is a listener function that is always listening to events.
Few events are :
Exit
disconnect
uncaughtException
rejectionHandled

If any uncaught exception occurs in your code flow, that exception will be caught in code shown below:

process.on('uncaughtException', function(err) {
    // handle the error safely
    console.log(err)
})

-->How do you resolve unhandled exceptions in a Node.js program?
using process
process.on('uncaughtException', function(err) {
    // handle the error safely
    console.log(err)
})

-->What are the standard Javascript errors?
InternalError 
Creates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. "too much recursion".

RangeError
Creates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.

ReferenceError
Creates an instance representing an error that occurs when de-referencing an invalid reference.

SyntaxError
Creates an instance representing a syntax error that occurs while parsing code in eval().

TypeError
Creates an instance representing an error that occurs when a variable or parameter is not of a valid type.

URIError
Creates an instance representing an error that occurs when encodeURI() or decodeURI() are passed invalid parameters.

-->What are the important command line options in Node.js?
To get a full list of all available Node.js CLI options in your current distribution of Node.js, you can access the manual page from the terminal using:
 man node=> will give list of all available Node.js CLI options
1)--version or -v=>you can print the version of Node.js 
2)--eval or -e=>Using the --eval option, you can run JavaScript code right from your terminal. 
   $ node -e 'console.log(3 + 2)'
   5  // o/p
3)--check or -c=>The --check option instructs Node.js to check the syntax of the provided file, without actually executing it.
   node --check index.js
	script necer run in this command

-->What are the important APIs in Timers module in Node.js?
the Timers module in Node.js contains functions that execute code after a set period of time. Timers do not need to be imported via require(), 
since all the methods are available globally
setTimeout()
setImmediate() --pending
setInterval()

clearTimeout();
clearImmediate();
clearInterval();

-->BUFFERS
https://www.w3resource.com/node.js/nodejs-buffer.php

-->MoDuLeS
Module in Node.js organized in single or multiple JavaScript files which can be reused throughout the Node.js application.Each module in Node.js has its own context, 
so it cannot interfere with other modules or pollute global scope. Also, each module can be placed in a separate .js file under a separate folder.

Node.js Core Modules:

In order to use Node.js core or NPM modules, you first need to import it using require() function as shown below.
var module = require('module_name');
As per above syntax, specify the module name in the require() function. The require() function will return an object, function, property or any other JavaScript type, 
depending on what the specified module returns.
module is a variable that represents current module and exports is an object that will be exposed as a module. So, whatever you assign to module.exports or exports,
 will be exposed as a module.
example->
var http = require('http');
var server = http.createServer(function(req, res){
  //write code here
});
server.listen(5000); 
In the above example, require() function returns an object because http every module returns its functionality as an object or we can say we get an instance to 
access the particular module's properties or functions, we can then use its properties and methods using dot notation e.g. http.createServer().

Node.js Local Module:

Local modules are modules created locally in your Node.js application. These modules include different functionalities of your application in separate files and 
folders. For example, if you need to connect to MongoDB and fetch data then you can create a module for it, which can be reused in your application.
 we can also package it and distribute it via NPM, so that Node.js community can use it.(pending about publishing package in npm registry)

example-->
//log.js file
var log = {
            info: function (info) { 
                console.log('Info: ' + info);
            },
            warning:function (warning) { 
                console.log('Warning: ' + warning);
            },
            error:function (error) { 
                console.log('Error: ' + error);
            }
    };

module.exports = log

In the above example of logging module, we have created an object with three functions - info(), warning() and error(). At the end, we have assigned this object 
to module.exports. The module.exports in the above example exposes a log object as a module so that we can use this module in our application after importing it 
using require.

The module.exports is a special object which is included in every JS file in the Node.js application by default. Use module.exports or exports to expose a function,
object or variable as a module in Node.js.

To use local modules in your application, you need to load it using require() function in the same way as core module. However, you need to specify the path of
JavaScript file of the module.
The following example demonstrates how to use the above logging module contained in Log.js.
var myLogModule = require('./Log.js');
myLogModule.info('Node.js started');
In the above example, app.js is using log module. First, it loads the logging module using require() function and specified path where logging module is stored. 
Logging module is contained in Log.js file in the root folder.

The require() function returns a log object because logging module exposes an object in Log.js using module.exports. So now you can use logging module as an object
 and call any of its function using dot notation e.g myLogModule.info() or myLogModule.warning() or myLogModule.error()

in detail about exporting module-->http://www.tutorialsteacher.com/nodejs/nodejs-module-exports

-->NODE PACKAGE MANAGER
http://www.tutorialsteacher.com/nodejs/what-is-node-package-manager

-->SERVING STATIC RESOURCES
http://www.tutorialsteacher.com/nodejs/serving-static-files-in-nodejs

-->What are some limitations of JavaScript?
Depends a lot on the browser: JavaScript depends a lot on the browser it runs on. Different browsers interpret JavaScript differently as the browsers have diverse 
JavaScript engines. Its always safer to test your code in all major browsers before pushing it to production.

Option to disable JavaScript: A lot of people tend to disable JavaScript in their browsers due to various security reasons. Think about all the websites that are
 highly dependent on client side scripts. If the user disables JavaScript, the web app is broken and it can't run on the browser which not only creates a problem 
for the web app but also for the user who is trying to enjoy a service!

There could be some, the only one I could think of, already has a solution, which is limitation to Client-side programming. However, Node.js which is a Javascript 
framework allows you to use JavaScript on the Server side.

-->body-parser 
Parse incoming request bodies in a middleware before your handlers,To handle HTTP POST request in Express.js version 4 and above, you need to install middleware module called body-parser.
body-parser extract the entire body portion of an incoming request stream and exposes it on req.body .

-->How Node.js overcomes the problem of blocking of I/O operations?  
Node.js solves this problem by putting the event based model at its core, using an event loop instead of threads.

-->How to check the already installed dependencies which are globally installed using npm?
Use the following command:

C:\Nodejs_WorkSpace>npm ls -g

-->What is a blocking code?
If application has to wait for some I/O operation in order to complete its execution any further then the code responsible for waiting is known as blocking code.

--> How many types of API functions are available in Node.js?

There are two types of API functions in Node.js:
Asynchronous, Non-blocking functions
Synchronous, Blocking functions

-->Q. How Node.js overcomes the problem of blocking of I/O operations?
-->Q. What is the difference between Node.js vs Ajax?
The difference between Node.js and Ajax is that, Ajax (short for Asynchronous Javascript and XML) is a client side technology, often used for updating the 
contents of the page without refreshing it. While,Node.js is Server Side Javascript, used for developing server software. Node.js does not execute in the browser 
but by the server.

-->Q. What is ‘Callback’ in node.js?
Callback function is used in node.js to deal with multiple requests made to the server. Like if you have a large file which is going to take a long time for a 
server to read and if you don’t want a server to get engage in reading that large file while dealing with other requests, call back function is used. Call back 
function allows the server to deal with pending request first and call a function when it is finished

-->CLUSTERS
https://www.sitepoint.com/how-to-create-a-node-js-cluster-for-speeding-up-your-apps/

-->REDIS
https://coligo.io/nodejs-api-redis-cache/
https://www.sitepoint.com/using-redis-node-js/

-->set NODE_ENV=development&& nodemon server.js

https://www.twilio.com/blog/2017/08/working-with-environment-variables-in-node-js.html
https://www.dynatrace.com/blog/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/
https://devcenter.heroku.com/articles/node-best-practices
Edit: Alright – but how do I set NODE_ENV properly?
I was asked that question on facebook after releasing this post and I agree that it really makes sense to cover that.

NODE_ENV works like any other environment variable (e.g. PATH) and it depends on your platform how to set it:

Linux and OSX: export NODE_ENV=production
Windows: SET NODE_ENV=production
On all platforms you can explicitly set it when starting your application like that: NODE_ENV=production node myapp.js. You may also use a module like dotenv to set it from an .env file in your application directory. That said, you should avoid setting the environment directly in your code because this contradicts the purpose of environment variables.
